# '*' 与 '&' 问题

## 功能：

**'*':** 乘号，声明指针，解引用

**'&':** 取地址符，标记引用

## 基本使用：

```c
int a = 5;
int* ptr;
ptr = &a;			// 把 a 的地址赋给指针 ptr
printf("%d", *ptr);		// 打印结果：5
```

**总结：** 这里用到了 指针 和 取地址符 的所有基本操作

* 声明指针: int* ptr
* 取地址: &a
* 解引用：*ptr

## 形参中的取地址符：

**'&'** 在函数声明中表示形参为 **引用类型**

```c
void f(int* &a)			// 这里 a 表示是对 ptr 的引用
{
	int b = 9;
	a = &b;			// 这里对 a 的操作实际上是对 ptr 的操作
}

int main()
{
	int* ptr;		// 这里声明了一个空指针
	f(ptr);
	printf("%d",*ptr);	// 打印结果为 9
}
```

**总结：** 形参前使用 '&' 符，表示是形参对实参的直接引用，也即指针 a 和指针 ptr 是同一个指针，对形参的所有操作，其实就是在操作实参。

## 形参中的指针变量：

**'*'** 在函数声明中也是值传递的一种形式

```c
void f(int* a)
{
	printf("mq-%d->%d\n", a, *a);	// mq-6487620->3
	*a = 10;	
	printf("mh-%d->%d\n", a, *a);	// mh-6487620->10
}

int main()
{
    int n = 3;
    int* ptr = &n;
    m(ptr);
    printf("m-%d->%d\n", ptr, n);	// m-6487620->10
}
```

这个过程中我们发现主函数中的 n 被修改了，且指针 a 和 指针 ptr 的值始终是一致的，共同指向 n 的地址，但是指针 a 和指针 ptr 其实是两个不同的指针。

也就是说这种操作本质上是形参对实参的拷贝，这种情况下只能对 ptr 指向的空间地址操作，而改变不了 ptr。

如下面这个过程：

```c
void f(int* a)
{
	printf("fq-%d\n", a);	// 打印结果：fq-6487620
	int b = 10;
	a = &b;			// 修改指针 a
	printf("fh-%d\n", a);	// 打印结果：fh-6487564
}

int main()
{
    int n = 3;
	int* ptr = &n;
	printf("mq-%d\n", ptr);	// 打印结果：mq-6487620
	f(ptr);
	printf("mh-%d\n", ptr);	// 打印结果：mh-6487620
}
```

在这个过程中，在函数中修改了指针 a 的值，我们可以清楚的发现，指针 ptr 并没有因此而改变。

**总结：** 在形参中的指针变量，其实是新定义的指针变量，拥有独立的存储空间，与实参没有关系。

